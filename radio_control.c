#include <stdio.h>#include <sys/select.h>#include <netinet/in.h>#include <sys/un.h>#include <sys/time.h>#include <sys/types.h>#include <unistd.h>#include <sys/socket.h>#include <sys/types.h>#include <string.h>#include <errno.h>#include <pthread.h>#include <unistd.h>#include <arpa/inet.h>#include <netdb.h>/**** FLAGS	***/#define Welcome 0#define Announce 1#define PermitSong 2#define InvalidCommand 3#define NewStations 4///////////////////////#define HELLO_SIZE 3#define WELCOME_SIZE 9#define ANNOUNCE_SIZE 3#define PERMIT_SIZE 2#define ASK_SIZE 3#define MAX_PROTCOLPACKET 263#define CLIENT_UP_SONG_BUFFER 1000#define UPSONG_RATE 8000#define BUFFERSIZE 1024typedef unsigned char unit8_t;typedef unsigned short unit16_t;typedef unsigned int unit32_t;typedef struct Hello{	unit8_t  commandType;	unit16_t reserved;}Hello;typedef struct AskSong{	unit8_t commandType;	unit16_t stationNumber;}AskSong;typedef struct UpSong{	unit8_t commandType;	unit32_t songSize; //size is in Bytes	unit8_t songNameSize;	unit8_t songName[256]; }UpSong;/********Global Vars*******/struct sockaddr_in addrUDP, addrTCP ;int TCPsocketID, UDPsocketID;struct ip_mreq multicastReq; unsigned short numStations;unsigned char* serverIPaddr; unsigned  char multicastarr [4]; int serverNumPort;unsigned short portNumMulticast; struct timeval *ptv;struct timeval tv;fd_set readfds; char SendSong_name[256];unsigned char serverCase;int userSwitchedStatio=1;int nowPlaying=0; // 0 not playing 1 currently listen to multicast groupint UpSongFlag=0;int HelloFlag=0;int recivedWelcomeFlag=0;int SendingFlag=0;int AskSongFlag=0;unit16_t newStationFlag=0;int permitFlag=0;int finigh_sendFlag=0;unsigned int fileLen=0;//Functions//unsigned int user_string(char *str, int len);int EventFormServer();int EventFormUser();void *listenerUDP();int WellcomeHandler(unsigned char *buffer);int PermitSongHandler(unsigned char *buffer);int InvalidCommandHandler(unsigned char *buffer);int AnnounceHandler(unsigned char *buffer);int ExitProgram();int CloseSocket(int sock);int SendSong();int UpSongHandler();void *Control( ){	int error=0,  Event=0, i=4;	TCPsocketID= socket(AF_INET,SOCK_STREAM, 0); //create a TCP socket	if(TCPsocketID==-1){ //check error		perror("\n\nCannot open Socket,The program will end\n\n");		return 1; 	}	// Configure settings of the server address struct //	memset (& addrTCP, 0, sizeof(addrTCP)); // reset with 0 all the fields	addrTCP.sin_family = AF_INET;  //IPV4	addrTCP.sin_port = htons(serverNumPort); // Set port number, using htons function to use proper byte order	addrTCP.sin_addr.s_addr = inet_addr(serverIPaddr);// Set IP address of the  SERVER we connect to	// Connect the socket to the server using the address struct //	if(connect(TCPsocketID, (struct sockaddr *) &addrTCP,  sizeof (addrTCP) )==-1){		perror("\n\n Connection Failed, The program will end\n\n");// faild to connect to the server		return 1;	}	Hello hello;	hello.commandType=0;	hello.reserved=0;	error=send(TCPsocketID,&hello,HELLO_SIZE,0);	if(error==-1){			perror("Couldn't send Hello massage");			CloseSocket(TCPsocketID);	}	HelloFlag=1;	ptv=&tv;	tv.tv_usec=100000;	while(1){	FD_ZERO (&readfds);	FD_SET (fileno(stdin),&readfds);	FD_SET (TCPsocketID,&readfds);	printf("\n");	Event=select(TCPsocketID+1,&readfds, NULL,NULL,ptv);	//Loop through all the FDs that need attention before sampling select() again    for(i=0;i<=Event;i++)	{	    	//STDIN FD         if(FD_ISSET(fileno(stdin),&readfds))        {			EventFormUser();			FD_CLR(fileno(stdin),&readfds);            continue;         }//Server FD        if(FD_ISSET(TCPsocketID,&readfds))        		{        			EventFormServer();        		   FD_CLR(TCPsocketID,&readfds);                   continue;                }				        if(Event==0)        {            printf("Time-out accured\n");           if(HelloFlag==1){		printf("\nThere was a time-out on Welcome message");		ptv=NULL;		ExitProgram();	}	if(AskSongFlag==1){		printf("\nThere was a time-out on Announce message");		ptv=NULL;		ExitProgram();	}	if(UpSongFlag==1){		printf("\nThere was a time-out on Permit message");		ptv=NULL;		ExitProgram();	}	if(finigh_sendFlag==1){		printf("\nThere was a time-out on New station message");		ptv=NULL;		ExitProgram();	}        }	}	}}void *listenerUDP(){	FILE *fp;	char multicastIPaddrStr[20];	int error;	char Song_Buffer[1024];	while(!recivedWelcomeFlag);	fp = popen("play -t mp3 -> /dev/null 2>&1", "w");//open a pipe. output is sent to dev/null (hell). . . .	//create a socket	UDPsocketID = socket(AF_INET, SOCK_DGRAM, 0);	if(UDPsocketID==-1)//check error	{		perror("\n\nCannot open UDP Socket, The program will terminate\n\n");		ExitProgram();	}		memset (& addrUDP, 0, sizeof(struct sockaddr_in)); // reset with 0 all the  sockaddr_in addrUDP struct we going to use	addrUDP.sin_family = AF_INET;  // Address family =   IPV4	addrUDP.sin_addr.s_addr = htonl(INADDR_ANY);// accept UDP connection from any ip address	addrUDP.sin_port = htons(portNumMulticast); // Set port number, using htons function to use proper byte order	//Bind //	error= bind(UDPsocketID, &addrUDP,sizeof (struct sockaddr_in));  	if(error==-1){		perror("\n\nCouldn't bind  to UDP, The program will end\n\n");		ExitProgram();	}		while(1)	{		if(userSwitchedStatio)		{			if(nowPlaying){				error=setsockopt(UDPsocketID, IPPROTO_IP, IP_DROP_MEMBERSHIP, &multicastReq, sizeof(struct ip_mreq));					if(error==-1){						perror("\n\n\n Failed to DROP MULTICAST \n");						exit(1);					}			}			//request to join to multicast group			sprintf(multicastIPaddrStr,"%d.%d.%d.%d",multicastarr[0],multicastarr[1],multicastarr[2],multicastarr[3]+newStationFlag);//the station the user chose			multicastReq.imr_multiaddr.s_addr=inet_addr(multicastIPaddrStr); // an ip multicast address input from user			multicastReq.imr_interface.s_addr = htonl(INADDR_ANY); // accept packest from any ip address source which is send to the  mutlicast IP			error=setsockopt(UDPsocketID, IPPROTO_IP, IP_ADD_MEMBERSHIP, &multicastReq, sizeof(struct ip_mreq));			if(error==-1){				perror("\n\nCant join the group, The program will terminate\n\n");// coudnt coonet to the tcp server				userSwitchedStatio=0;				ExitProgram();			}			nowPlaying=1;			userSwitchedStatio=0;		}		if(nowPlaying){			// we joined the group so Read the message from the source of the multicast address into the buffer and print it			error=recv(UDPsocketID, Song_Buffer, BUFFERSIZE, 0);			if(error==-1){				perror("\n\nFailed to receive DATA, The program will terminate\n\n"); // couldn't connect to the  server				ExitProgram();			}				if(error==0)	break; //this would indicate us that the connection is closed (FIN-ACK)			fwrite (Song_Buffer , sizeof(char), BUFFERSIZE, fp);//write a buffer of size numbyts into fp		}	}	pclose(fp);	//close the socket	error=close(UDPsocketID);	if(error==-1) {	  	perror("\n\nUDP socket wasn't closed\n");	  	ExitProgram();	}}int main(int argc, char **argv){	pthread_t thUDPid, thTCPid;if (argc != 3) {        puts("RADIO_CONTROLL: <server IP> <port num>");		return 1;	}	serverIPaddr=argv[1];	strcpy(serverIPaddr,argv[1]);	serverNumPort=atoi(argv[2]);	strcpy(serverIPaddr,argv[1]);	if(inet_addr(serverIPaddr)==-1){			puts("Multicast IP is bad");			puts("RADIO_CONTROLL: <server IP> <port num>");			return 1;		}	serverNumPort=atoi(argv[2]);	if(serverNumPort<1000)	{		puts("TCP port is out of range");		puts("RADIO_CONTROLL: <server IP> <port num>");		return 1;	}	pthread_create(&thUDPid,0,listenerUDP,0);	pthread_create(&thTCPid,0,Control,0);    pthread_join(thTCPid, NULL);}int EventFormServer(){	int temp;	unsigned char buffer[MAX_PROTCOLPACKET]={0};	ptv=NULL;	memset (& buffer, 0, sizeof( buffer));		temp=recv(TCPsocketID, buffer, MAX_PROTCOLPACKET, 0);		if(temp==-1){			perror("\n\nFailed to receive welcome data, The program will terminate\n\n");// coudnt read data from server			return 1;		}	serverCase=buffer[0];	switch(serverCase){	case (Welcome):				{					printf("\nWelcome");					if(!HelloFlag || SendingFlag){						printf("\nUnexpected Welcome");						ExitProgram();					}					HelloFlag=0;					WellcomeHandler(buffer);					break;				}	case (Announce):			{				printf("\nAnnounce");				if(!AskSongFlag|| SendingFlag){					printf("\nUnexpected Announce");					ExitProgram();				}				AskSongFlag=0;				AnnounceHandler(buffer);				break;			}	case (PermitSong):					{						if(!UpSongFlag || SendingFlag){							printf("\nUnexpected PermitSong");							ExitProgram();						}						UpSongFlag=0;						PermitSongHandler(buffer);						break;					}	case (InvalidCommand):				{					InvalidCommandHandler(buffer);					ExitProgram();					break;				}	case (NewStations):				{					if(HelloFlag || SendingFlag){						printf("\nUnexpected PermitSong");						ExitProgram();					}					UpSongFlag=0;					finigh_sendFlag=0;					numStations=buffer[1]*256+buffer[2];                    printf("\nRADIO_CONTROL: New song is available,The number of stations is %d",numStations);					break;				}	 default: 				 {				    printf("\nInvalid protocol message!!!");                    ExitProgram();					printf("Radio_Control: invalid massage to the protocol");					ExitProgram();					break;				 }	}//switch	return 1;}int EventFormUser(){	char str[500];	int len=498 , strlen=0,i =0;	strlen= user_string(str,len); //get input from user	if(strcmp(str,"s") == 0){		printf("\nRadio_Control: UPLOAD SONG MODE\n");		UpSongHandler();		return 1;	}	else if(strcmp(str,"q") == 0)	{		ExitProgram();	}	else if(strcmp(str,"\r") == 0)	{		printf("\nRadio_Control: Please Retry by enter a station number, 's' to send a song or 'q' to quit\n");		return 1;	}	else{		for(i=0;i<strlen;i++){			if(isdigit(str[i])!=1){							printf("\nRadio_Control: Please Retry by enter a station number, 's' to send a song or 'q' to quit\n");				return 1;				}			}		newStationFlag=atoi(str);		if(newStationFlag<numStations){			AskSongHandler();			return 1;		}		else{			printf("\nRadio_Control: Please Retry by enter a station number, 's' to send a song or 'q' to quit\n");		}	}return 1;}unsigned int user_string(char *str, int len){	len=len+2; // this would help us to see if the user to exceeds the max length	int length=0;	do{		fgets(str,len,stdin); 						str[strcspn(str, "\r\n")] = '\0';			length=strlen(str); 								if(length>=len-1) 										printf("The string is over the allowed length");		if(length==len-1) while(getchar()!='\n'); 		}while(length>=len-1);								return strlen(str);}int WellcomeHandler(unsigned char *buffer){		numStations=buffer[1]*256+buffer[2];		if(numStations==0) userSwitchedStatio=0; // dont start station 0		multicastarr[3]=buffer[3];		multicastarr[2]=buffer[4];		multicastarr[1]=buffer[5];		multicastarr[0]=buffer[6];		portNumMulticast=buffer[7]*256+buffer[8];		printf("Radio base station ip: %d.%d.%d.%d \n", multicastarr[0],multicastarr[1],multicastarr[2],multicastarr[3]);	    printf("Number of stations: %d \n", numStations);	    printf("PortNumber %d\n",portNumMulticast);		printf("Radio_CONTROL:\n 1.Please enter number of station\n 2. Please enter 's' to upload a Song name\n 3. please enter 'q' to quit the controller");		recivedWelcomeFlag=1;		return 1;}int AskSongHandler(){	AskSong asksong;	int error;	memset (& asksong, 0, sizeof(asksong));	asksong.commandType=1;	asksong.stationNumber=newStationFlag;	error=send(TCPsocketID,&asksong,ASK_SIZE,0);		if(error==-1){				perror("Couldn't send ASKSONG massage");				ExitProgram();	}	AskSongFlag=1;	tv.tv_usec=100000;	ptv=&tv;	return 1;}int AnnounceHandler(unsigned char* buffer){	int i=0;	int songNameSize=buffer[1];	char songName[256];	for(i=2;i<songNameSize+2;i++){		songName[i-2]=buffer[i];	}	userSwitchedStatio=1;	printf("\nRADIO_CONTROL: Song in the station %d is: %s\n",newStationFlag, songName);		return 1;}int PermitSongHandler(unsigned char* buffer){	int permit=buffer[1];	if(permit==1){		SendingFlag=1;		permitFlag=1;		SendSong(); 		SendingFlag=0; 		permitFlag=0;	}	else	{		permit=0;		printf("\nRADIO_CONTROL: Cannot send this song, Permit 0");	}		return permit;}int InvalidCommandHandler (unsigned char* buffer){	int repleyStringSize=(int)buffer[1],i;	char* repleyString;	for(i=2;i<repleyStringSize+2;i++){		repleyString[i-2]=buffer[i];		printf("\nRADIO_CONTROL: i:%d, %d\n",i,repleyString[i-2]);	}	printf("RADIO_CONTROL: Invalid Command: %s\n",repleyString);	printf("\nRADIO_CONTROL:Size of invalid:%d\n",repleyStringSize);	ExitProgram();	return 1;}int ExitProgram(){	printf("\nRADIO_CONTROL: Goodbye!!!\n\n");	CloseSocket(TCPsocketID);	CloseSocket(UDPsocketID);	pthread_exit(1);	return 1;}int CloseSocket(int sock){	int closeError;	closeError=close(sock);	if(closeError==-1){			perror("\nTCP SOCKET wasn't closed, The program will terminate\n\n");			return 1;	}	return 1;}int UpSongHandler(){	UpSong upSong_message;	unsigned  char *ptr;	unsigned int l=254,error,Song_Name_len=0;	unsigned char Buffer_UPSONG[262];	FILE* fp;	int i=0;		printf("Enter Song Name:");	Song_Name_len=user_string(SendSong_name,l);	fp=fopen(SendSong_name,"r");	if(fp==NULL){		printf("\nRadio_CONTROL: File doesn't exist");		return 1;	}	memset(& upSong_message, 0, sizeof(upSong_message));	memset(& Buffer_UPSONG, 0, sizeof(Buffer_UPSONG));	fseek(fp, 0, SEEK_END);	fileLen=ftell(fp);	fseek(fp, 0, SEEK_SET);		if(fileLen<2000) 	{		puts(" You will need to send a minimum of 2000 bytes");		return 1;	}	if(fileLen>10000000) 	{		puts("This file is too big ,shouldn't be more then 10000000 bytes");		return 1;	}	upSong_message.commandType=(unsigned char)2; 	upSong_message.songSize=(unsigned int)fileLen;	upSong_message.songNameSize=(unsigned char)Song_Name_len;	strcpy(upSong_message.songName,SendSong_name);	Buffer_UPSONG[0]=upSong_message.commandType;	Buffer_UPSONG[1]=(upSong_message.songSize)/(16777216);	Buffer_UPSONG[2]=(upSong_message.songSize%16777216)/(65536);	Buffer_UPSONG[3]=(upSong_message.songSize%65536)/(256);	Buffer_UPSONG[4]=(upSong_message.songSize%256);	Buffer_UPSONG[5]=upSong_message.songNameSize;	strcpy(&Buffer_UPSONG[6],SendSong_name);	error=send(TCPsocketID,Buffer_UPSONG,6+upSong_message.songNameSize,0);	if(error==-1){		perror("Couldn't send UPSong message ");		ExitProgram();	}	UpSongFlag=1;	tv.tv_usec=100000;	ptv=&tv;	return 1;}int SendSong(){	int i=0,len;	unsigned int countBytesSent=0, bufferSize=CLIENT_UP_SONG_BUFFER;	int temp;	size_t result;	unsigned char* buffer;	FILE* fp;	printf("\nStart Send song\n");	if((fp=fopen(SendSong_name,"rb"))==NULL){		printf("\nCouldn't open %s FILE\n",SendSong_name);		ExitProgram();	}	fseek(fp, 0, SEEK_END);	fileLen=ftell(fp);	rewind (fp);	buffer = (unsigned char*) calloc (fileLen, sizeof(char)); // allocate memory to contain the whole file:	 if (buffer == NULL) {		  fputs ("Memory error",stderr);		  ExitProgram();	  }	  // copy the file into the buffer:	  result = fread (buffer,1,fileLen,fp);	  if (result != fileLen) {		  fputs ("Reading error",stderr);		  ExitProgram();	  }	  countBytesSent=0;	  printf("\nPlease wait while we are Uploading the Song: %s (%dBytes)\n",SendSong_name, fileLen);	  len=fileLen/1000;	  for(i=0;countBytesSent<=fileLen;i++)	  {			if(countBytesSent+bufferSize > fileLen) break;			temp=sendto(TCPsocketID,&buffer[countBytesSent],bufferSize,0,(struct sockaddr *)&TCPsocketID,sizeof(TCPsocketID));			usleep(UPSONG_RATE);			countBytesSent+=temp;			if(temp==-1){			perror("\n ERROR while Sending song");			printf("Percentage done: %d",(i/len)*100);			free(buffer);			ExitProgram();		}	  }	  printf("\nSong size:%d\n",countBytesSent);		len=fileLen-countBytesSent;		if(len>0){		temp=sendto(TCPsocketID,&buffer[countBytesSent],len,0,(struct sockaddr *)&TCPsocketID,sizeof(TCPsocketID));		countBytesSent+=temp;}	fclose(fp);	free(buffer);	printf("\nStatus: Finished sending song \n");	printf("\nSong Size:%d\n",countBytesSent);	memset(&SendSong_name, 0, sizeof(SendSong_name));	fileLen=0;	tv.tv_sec=2;	ptv=&tv;	finigh_sendFlag=1;	numStations++;	return 1;}